# Recursion
-> Function that calls itself to solve a problem
-> Breaks down complex problems into smaller parts
-> Must have a base case

# Key components:
1. Base case: condition to stop recursion (prevent infinite loops)
2. Recursive case: function calls itself with modified parameters
3. Progress: each call should move towards the base case

# Example 1: Countdown
def countdown(n):
    # base case
    if n <= 0:
        return
    print(n)
    countdown(n-1)

countdown(5)

# Example 2: Factorial
def factorial(n):
    # base case
    if n == 1 or n == 0:
        return 1
    return n * factorial(n-1)

result = factorial(5)
print(result)

# Expansion:
# 5*factorial(4)
# 5*(4*factorial(3))
# 5*(4*(3*factorial(2)))
# 5*(4*(3*(2*factorial(1))))
# 5*(4*(3*(2*1)))

# Example 3: Fibonacci sequence
# Formula: f(n) = f(n-1) + f(n-2)
# Sequence: 0, 1, 1, 2, 3, 5, 8, 13

def fibonacci(n):
    # base case
    if n <= 0:
        return 0
    if n == 1:
        return 1
    # recursive case
    return fibonacci(n-1) + fibonacci(n-2)

for i in range(8):
    print(f'fibonacci({i}) = {fibonacci(i)}')


# Lambda Functions (Anonymous Functions)

-> Small, anonymous (nameless) functions
-> Defined using "lambda" keyword
-> Can have multiple parameters but only one expression
-> Return value automatically (no "return" keyword needed)

Syntax:
lambda arguments : expression

Use cases:
- Short, simple operations
- Functions needed temporarily
- When logic fits in one expression
- Common with map(), filter(), sorted(), reduce()

# Example 1: Regular vs Lambda
def add_regular(x, y):
    return x + y

print(f"regular function : add_regular(5,3) = {add_regular(5,3)}")

add_lambda = lambda x, y: x + y
print(f"lambda function : add_lambda(5,3) = {add_lambda(5,3)}")

# Example 2: Single argument lambdas
square = lambda x: x**2
cube = lambda x: x**3
double = lambda x: x*2

print("square :", square(5))
print("cube :", cube(5))
print("double :", double(5))

# Example 3: Lambda with map()
nums = [1,2,3,4,5]
print("original list :", nums)

squares = list(map(lambda x: x**2, nums))
print("squares :", squares)

strings = list(map(lambda x: str(x), nums))
print("strings :", strings)

# Example 4: Lambda with filter()
num = [1,2,3,4,5,6,7,8,9,10]

evens = list(filter(lambda x: x % 2 == 0, num))
print("even numbers :", evens)

greater = list(filter(lambda x: x > 5, num))
print("greater numbers :", greater)

# Example 5: Lambda with sorted()
students = [
    {"name":"Alice", "age":25, "grade":85},
    {"name":"Bob", "age":23, "grade":87},
    {"name":"Bill", "age":22, "grade":77}
]

print("original list :")
for s in students:
    print(s)

print("by age")
by_age = sorted(students, key=lambda x: x["age"])
for s in by_age:
    print(s)

print("by grade (descending)")
by_grade = sorted(students, key=lambda x: x["grade"], reverse=True)
for s in by_grade:
    print(s)

# Example 6: Lambda with reduce()
from functools import reduce
n = [1,2,3,4,5]

# product of all numbers
product = reduce(lambda x, y: x*y, n)
print("product :", product)

# maximum number
maximum = reduce(lambda x, y: x if x > y else y, n)
print("maximum :", maximum)